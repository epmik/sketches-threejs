<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <link type="text/css" rel="stylesheet" href="main.css" />
    <style>
      #blocker {
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
      }
      #instructions {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        font-size: 14px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="blocker">
      <div id="instructions">
        <p style="font-size:36px">Click to play</p>
        <p>
          Move: WASD<br />
          Jump: SPACE<br />
          Look: MOUSE
        </p>
      </div>
    </div>
    <script type="importmap">
      {
          "imports": {
              "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
              "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
          }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
      // Remove unused imports if not needed:
      // import { CameraControls } from './.js/CameraControls.js';
      // import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';

      let camera, scene, renderer, controls;
      let portal;
      const frustum = new THREE.Frustum();
      const cameraViewProjectionMatrix = new THREE.Matrix4();

      // Variables for keyboard movement
      const move = { forward: false, backward: false, left: false, right: false };
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      const speed = 100;
      let prevTime = performance.now();
      let visible = null;

      init();
      animate();

      function init() {
        // Define instructions and blocker elements.
        const instructions = document.getElementById("instructions");
        const blocker = document.getElementById("blocker");

        // Create scene and camera
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x808080);

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 10, 50);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create a 50x50 plane (aligned along the xz-plane)
        const planeGeometry = new THREE.PlaneGeometry(50, 50);
        const planeMaterial = new THREE.MeshBasicMaterial({
          color: 0x999999,
          side: THREE.DoubleSide
        });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        scene.add(plane);

        // Create the portal: a quad along the xy-plane
        const portalGeometry = new THREE.PlaneGeometry(5, 10);
        const yellowMaterial = new THREE.MeshBasicMaterial({
          color: 0xffff00,
          side: THREE.DoubleSide
        });
        portal = new THREE.Mesh(portalGeometry, yellowMaterial);
        // Position the portal (e.g., centered above the plane)
        portal.position.set(0, 5, 0);
        // Random rotation around the y-axis
        portal.rotation.y = Math.random() * Math.PI * 2;
        scene.add(portal);

        // Optional: add some ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // Set up PointerLockControls for mouse look and keyboard movement
        controls = new PointerLockControls(camera, document.body);

        instructions.addEventListener("click", function () {
          controls.lock();
        });

        controls.addEventListener("lock", function () {
          instructions.style.display = 'none';
          blocker.style.display = 'none';
        });

        controls.addEventListener("unlock", function () {
          blocker.style.display = 'block';
          instructions.style.display = '';
        });

        // Keyboard event listeners for movement
        document.addEventListener("keydown", onKeyDown, false);
        document.addEventListener("keyup", onKeyUp, false);
        window.addEventListener("resize", onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onKeyDown(event) {
        switch (event.code) {
          case "KeyW":
            move.forward = true;
            break;
          case "KeyS":
            move.backward = true;
            break;
          case "KeyA":
            move.left = true;
            break;
          case "KeyD":
            move.right = true;
            break;
        }
      }

      function onKeyUp(event) {
        switch (event.code) {
          case "KeyW":
            move.forward = false;
            break;
          case "KeyS":
            move.backward = false;
            break;
          case "KeyA":
            move.left = false;
            break;
          case "KeyD":
            move.right = false;
            break;
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        const time = performance.now();
        const delta = (time - prevTime) / 1000;
        prevTime = time;

        // Update movement based on keyboard input
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

        direction.z = Number(move.forward) - Number(move.backward);
        direction.x = Number(move.right) - Number(move.left);
        direction.normalize();

        if (move.forward || move.backward) velocity.z -= direction.z * speed * delta;
        if (move.left || move.right) velocity.x -= direction.x * speed * delta;

        // Move the camera using PointerLockControls methods
        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);

        // Check if the portal is inside the camera frustum using our rectangular quad method
        if (isRectangularQuadIntersectingFrustum(portal, camera)) {
          portal.material.color.set(0xff0000); // red when visible
          if (visible !== true) {
            visible = true;
            console.log('visible');
          }
        } else {
          portal.material.color.set(0xffff00); // yellow when not visible
          if (visible !== false) {
            visible = false;
            console.log('not visible');
          }
        }

        renderer.render(scene, camera);
      }

      // Helper: Extract unique world-space vertices from the quad's geometry.
      function getQuadWorldVertices(mesh) {
        const vertices = [];
        const posAttr = mesh.geometry.attributes.position;
        for (let i = 0; i < posAttr.count; i++) {
          const v = new THREE.Vector3().fromBufferAttribute(posAttr, i);
          mesh.localToWorld(v);
          if (!vertices.some(u => u.distanceToSquared(v) < 1e-6)) {
            vertices.push(v);
          }
        }
        return vertices;
      }

      // Helper: Transform a world-space vertex into NDC.
      function worldToNDC(vertex, vpMatrix) {
        const v4 = new THREE.Vector4(vertex.x, vertex.y, vertex.z, 1);
        v4.applyMatrix4(vpMatrix);
        return new THREE.Vector3(v4.x / v4.w, v4.y / v4.w, v4.z / v4.w);
      }

      // This function assumes the quad is rectangular.
      // It projects the quad's four corners to NDC, computes their AABB,
      // and returns true if that AABB intersects the clip volume [-1, 1]^3.
      function isRectangularQuadIntersectingFrustum(mesh, camera) {
        // Compute view-projection matrix: VP = projectionMatrix * matrixWorldInverse.
        const vpMatrix = new THREE.Matrix4();
        vpMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

        // Get the quad's unique vertices and project them to NDC.
        const worldVerts = getQuadWorldVertices(mesh);
        if (worldVerts.length === 0) return false;
        const ndcVerts = worldVerts.map(v => worldToNDC(v, vpMatrix));

        // Compute the axis-aligned bounding box (AABB) of the projected vertices.
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        let minZ = Infinity, maxZ = -Infinity;

        for (const v of ndcVerts) {
          if (v.x < minX) minX = v.x;
          if (v.x > maxX) maxX = v.x;
          if (v.y < minY) minY = v.y;
          if (v.y > maxY) maxY = v.y;
          if (v.z < minZ) minZ = v.z;
          if (v.z > maxZ) maxZ = v.z;
        }

        // Check if the AABB overlaps the NDC clip volume ([-1, 1] in all axes).
        if (maxX < -1 || minX > 1) return false;
        if (maxY < -1 || minY > 1) return false;
        if (maxZ < -1 || minZ > 1) return false;

        return true;
      }
    </script>
  </body>
</html>
